"use client"

import { useCallback, useEffect, useMemo, useState } from "react"
import { ClipboardCheck, Eye, FileDown, Link2, Trash2 } from "lucide-react"
import { DynamicTable, type Column } from "./dynamic-table"
import { ListHeader } from "./list-header"
import type { BulkActionsGridProps } from "./bulk-actions-grid"
import { calculateMinWidth } from "@/lib/column-width-utils"
import { cn } from "@/lib/utils"
import type { DepositLineItemRow, SuggestedMatchScheduleRow } from "@/lib/mock-data"
import { useToasts } from "./toast"
import {
  DepositLineStatusFilterDropdown,
  type DepositLineStatusFilterValue
} from "./deposit-line-status-filter-dropdown"
import {
  ReconciliationScheduleStatusFilterDropdown,
  type ReconciliationScheduleFilterValue
} from "./reconciliation-schedule-status-filter-dropdown"

export interface DepositReconciliationMetadata {
  id: string
  depositName: string
  depositDate: string
  createdBy: string
  paymentType: string
  usageTotal: number
  unallocated: number
  allocated: number
}

type LineTabKey = DepositLineStatusFilterValue
type ScheduleTabKey = ReconciliationScheduleFilterValue

const lineStatusStyles: Record<DepositLineItemRow["status"], string> = {
  Matched: "bg-emerald-100 text-emerald-700 border border-emerald-200",
  Unreconciled: "bg-red-100 text-red-700 border border-red-200",
  "Partially Matched": "bg-amber-100 text-amber-700 border border-amber-200"
}

const scheduleStatusStyles: Record<SuggestedMatchScheduleRow["status"], string> = {
  Suggested: "bg-indigo-50 text-indigo-700 border border-indigo-200",
  Reconciled: "bg-emerald-50 text-emerald-700 border border-emerald-200",
  "Un-Reconciled": "bg-amber-50 text-amber-700 border border-amber-200"
}

interface DepositReconciliationDetailViewProps {
  metadata: DepositReconciliationMetadata
  lineItems: DepositLineItemRow[]
  schedules: SuggestedMatchScheduleRow[]
  loading?: boolean
}

interface MetaStatProps {
  label: string
  value: string
  emphasis?: boolean
  wrapValue?: boolean
}

function MetaStat({ label, value, emphasis = false, wrapValue = false }: MetaStatProps) {
  return (
    <div className="px-1">
      <p className="text-[11px] font-semibold uppercase tracking-wide text-slate-500">{label}</p>
      <p
        className={cn(
          "mt-0.5 font-semibold text-slate-900",
          emphasis ? "text-base" : "text-sm",
          wrapValue ? "break-all" : undefined
        )}
      >
        {value}
      </p>
    </div>
  )
}

export function DepositReconciliationDetailView({
  metadata,
  lineItems,
  schedules,
  loading = false
}: DepositReconciliationDetailViewProps) {
  const { showSuccess, showError, ToastContainer } = useToasts()
  const [lineTab, setLineTab] = useState<LineTabKey>("matched")
  const [scheduleTab, setScheduleTab] = useState<ScheduleTabKey>("suggested")
  const [lineSearch, setLineSearch] = useState("")
  const [scheduleSearch, setScheduleSearch] = useState("")
  const [lineItemRows, setLineItemRows] = useState<DepositLineItemRow[]>(lineItems)
  const [scheduleRows, setScheduleRows] = useState<SuggestedMatchScheduleRow[]>(schedules)
  const [selectedLineItems, setSelectedLineItems] = useState<string[]>([])
  const [selectedSchedules, setSelectedSchedules] = useState<string[]>([])

  useEffect(() => {
    setLineItemRows(lineItems)
    setSelectedLineItems(previous => previous.filter(id => lineItems.some(item => item.id === id)))
  }, [lineItems])

  useEffect(() => {
    setScheduleRows(schedules)
    setSelectedSchedules(previous => previous.filter(id => schedules.some(item => item.id === id)))
  }, [schedules])

  const currencyFormatter = useMemo(
    () =>
      new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 2
      }),
    []
  )
  const percentFormatter = useMemo(
    () =>
      new Intl.NumberFormat("en-US", {
        style: "percent",
        minimumFractionDigits: 0,
        maximumFractionDigits: 2
      }),
    []
  )
  const dateFormatter = useMemo(
    () =>
      new Intl.DateTimeFormat("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric"
      }),
    []
  )

  const lineSearchValue = lineSearch.trim().toLowerCase()
  const scheduleSearchValue = scheduleSearch.trim().toLowerCase()

  const filteredLineItems = useMemo(() => {
    return lineItemRows.filter(item => {
      const matchesTab =
        lineTab === "all"
          ? true
          : lineTab === "matched"
            ? item.status === "Matched"
            : lineTab === "unmatched"
              ? item.status === "Unreconciled"
              : item.status === "Partially Matched"

      const matchesSearch = lineSearchValue
        ? [item.accountName, item.accountId, item.productName]
            .map(value => value.toLowerCase())
            .some(value => value.includes(lineSearchValue))
        : true

      return matchesTab && matchesSearch
    })
  }, [lineItemRows, lineTab, lineSearchValue])

  const filteredSchedules = useMemo(() => {
    return scheduleRows.filter(schedule => {
      const matchesTab =
        scheduleTab === "all"
          ? true
          : scheduleTab === "suggested"
            ? schedule.status === "Suggested"
            : scheduleTab === "reconciled"
              ? schedule.status === "Reconciled"
              : schedule.status === "Un-Reconciled"

      const matchesSearch = scheduleSearchValue
        ? [
            schedule.name,
            schedule.number,
            schedule.accountLegalName,
            schedule.product,
            schedule.vendorName
          ]
            .map(value => value.toLowerCase())
            .some(value => value.includes(scheduleSearchValue))
        : true

      return matchesTab && matchesSearch
    })
  }, [scheduleRows, scheduleTab, scheduleSearchValue])

  const lineColumns = useMemo<Column[]>(() => {
    return [
      {
        id: "match",
        label: "Match",
        width: 140,
        minWidth: 120,
        accessor: "id",
        render: () => (
          <button
            type="button"
            className="rounded-full border border-primary-200 bg-white px-4 py-1.5 text-sm font-semibold text-primary-600 transition hover:bg-primary-50"
          >
            Match
          </button>
        )
      },
      {
        id: "status",
        label: "Status",
        width: 160,
        minWidth: calculateMinWidth({ label: "Status", type: "text", sortable: false }),
        render: (value: DepositLineItemRow["status"]) => (
          <span className={cn("inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold", lineStatusStyles[value])}>
            {value}
          </span>
        )
      },
      {
        id: "paymentDate",
        label: "Payment Date",
        width: 160,
        minWidth: calculateMinWidth({ label: "Payment Date", type: "text", sortable: false }),
        render: (value: string) => {
          const parsed = new Date(value)
          return Number.isNaN(parsed.getTime()) ? value : dateFormatter.format(parsed)
        }
      },
      {
        id: "accountName",
        label: "Account",
        width: 200,
        minWidth: calculateMinWidth({ label: "Account", type: "text", sortable: false })
      },
      {
        id: "lineItem",
        label: "Line Item",
        width: 120,
        minWidth: 100
      },
      {
        id: "productName",
        label: "Product Name",
        width: 220,
        minWidth: 200
      },
      {
        id: "usage",
        label: "Usage",
        width: 140,
        minWidth: 120,
        render: (value: number) => currencyFormatter.format(value)
      },
      {
        id: "commission",
        label: "Commission",
        width: 140,
        minWidth: 120,
        render: (value: number) => currencyFormatter.format(value)
      },
      {
        id: "commissionRate",
        label: "Commission Rate",
        width: 160,
        minWidth: 140,
        render: (value: number) => percentFormatter.format(value)
      },
      {
        id: "accountId",
        label: "Account ID",
        width: 160,
        minWidth: 140
      }
    ]
  }, [currencyFormatter, percentFormatter, dateFormatter])

  const scheduleColumns = useMemo<Column[]>(() => {
    return [
      {
        id: "actions",
        label: "Actions",
        width: 160,
        minWidth: 100,
        accessor: "id",
        render: () => (
          <div className="flex items-center gap-1 text-primary-500">
            {[Eye, Link2, ClipboardCheck, FileDown, Trash2].map((Icon, index) => (
              <button
                type="button"
                key={index}
                className="rounded-full border border-transparent p-1.5 transition hover:border-primary-100 hover:bg-primary-50"
                aria-label="Schedule action"
              >
                <Icon className="h-4 w-4" />
              </button>
            ))}
          </div>
        )
      },
      {
        id: "sequence",
        label: "#",
        width: 60,
        minWidth: calculateMinWidth({ label: "#", type: "text", sortable: false })
      },
      {
        id: "name",
        label: "Name",
        width: 140,
        minWidth: calculateMinWidth({ label: "Name", type: "text", sortable: false })
      },
      {
        id: "date",
        label: "Date",
        width: 160,
        minWidth: calculateMinWidth({ label: "Date", type: "text", sortable: false }),
        render: (value: string) => {
          const parsed = new Date(value)
          return Number.isNaN(parsed.getTime()) ? value : dateFormatter.format(parsed)
        }
      },
      {
        id: "accountLegalName",
        label: "Account Legal Name",
        width: 220,
        minWidth: calculateMinWidth({ label: "Account Legal Name", type: "text", sortable: false })
      },
      {
        id: "product",
        label: "Product",
        width: 220,
        minWidth: calculateMinWidth({ label: "Product", type: "text", sortable: false })
      },
      {
        id: "vendorName",
        label: "Vendor Name",
        width: 180,
        minWidth: calculateMinWidth({ label: "Vendor Name", type: "text", sortable: false })
      },
      {
        id: "quantity",
        label: "Quantity",
        width: 120,
        minWidth: calculateMinWidth({ label: "Quantity", type: "text", sortable: false })
      },
      {
        id: "priceEach",
        label: "Price Each",
        width: 140,
        minWidth: calculateMinWidth({ label: "Price Each", type: "text", sortable: false }),
        render: (value: number) => currencyFormatter.format(value)
      },
      {
        id: "expectedUsageGross",
        label: "Expected Usage Gross",
        width: 200,
        minWidth: calculateMinWidth({ label: "Expected Usage Gross", type: "text", sortable: false }),
        render: (value: number) => currencyFormatter.format(value)
      },
      {
        id: "expectedUsageAdjust",
        label: "Expected Usage Adjust",
        width: 200,
        minWidth: calculateMinWidth({ label: "Expected Usage Adjust", type: "text", sortable: false }),
        render: (value: number) => currencyFormatter.format(value)
      },
      {
        id: "status",
        label: "Status",
        width: 160,
        minWidth: calculateMinWidth({ label: "Status", type: "text", sortable: false }),
        render: (value: SuggestedMatchScheduleRow["status"]) => (
          <span className={cn("inline-flex items-center rounded-full px-3 py-1 text-xs font-semibold", scheduleStatusStyles[value])}>
            {value}
          </span>
        )
      }
    ]
  }, [currencyFormatter, dateFormatter])

  const handleLineItemSelect = useCallback((lineId: string, selected: boolean) => {
    setSelectedLineItems(previous => {
      if (selected) {
        if (previous.includes(lineId)) return previous
        return [...previous, lineId]
      }
      return previous.filter(id => id !== lineId)
    })
  }, [])

  const handleLineItemSelectAll = useCallback(
    (selected: boolean) => {
      if (selected) {
        setSelectedLineItems(filteredLineItems.map(item => item.id))
        return
      }
      setSelectedLineItems([])
    },
    [filteredLineItems]
  )

  const handleScheduleSelect = useCallback((scheduleId: string, selected: boolean) => {
    setSelectedSchedules(previous => {
      if (selected) {
        if (previous.includes(scheduleId)) return previous
        return [...previous, scheduleId]
      }
      return previous.filter(id => id !== scheduleId)
    })
  }, [])

  const handleScheduleSelectAll = useCallback(
    (selected: boolean) => {
      if (selected) {
        setSelectedSchedules(filteredSchedules.map(schedule => schedule.id))
        return
      }
      setSelectedSchedules([])
    },
    [filteredSchedules]
  )

  const handleBulkLineMatch = useCallback(() => {
    if (selectedLineItems.length === 0) {
      showError("No line items selected", "Select at least one deposit line item to match.")
      return
    }
    setLineItemRows(previous =>
      previous.map(item =>
        selectedLineItems.includes(item.id) ? { ...item, status: "Matched" } : item
      )
    )
    setSelectedLineItems([])
    showSuccess(
      `${selectedLineItems.length} line item${selectedLineItems.length === 1 ? "" : "s"} matched`,
      "The selected line items were marked as Matched."
    )
  }, [selectedLineItems, showError, showSuccess])

  const handleBulkLineUnmatch = useCallback(() => {
    if (selectedLineItems.length === 0) {
      showError("No line items selected", "Select at least one deposit line item to update.")
      return
    }
    setLineItemRows(previous =>
      previous.map(item =>
        selectedLineItems.includes(item.id) ? { ...item, status: "Unreconciled" } : item
      )
    )
    setSelectedLineItems([])
    showSuccess(
      `${selectedLineItems.length} line item${selectedLineItems.length === 1 ? "" : "s"} updated`,
      "The selected line items were marked as Unreconciled."
    )
  }, [selectedLineItems, showError, showSuccess])

  const handleBulkLineExport = useCallback(() => {
    if (selectedLineItems.length === 0) {
      showError("No line items selected", "Select at least one line item to export.")
      return
    }
    const rows = lineItemRows.filter(item => selectedLineItems.includes(item.id))
    if (rows.length === 0) {
      showError("Line items unavailable", "Unable to locate the selected line items.")
      return
    }
    const headers = [
      "Account",
      "Payment Date",
      "Line Item",
      "Product Name",
      "Usage",
      "Commission",
      "Commission Rate",
      "Account ID",
      "Status"
    ]
    const escapeCsv = (value: unknown) => {
      if (value === null || value === undefined) return ""
      const stringValue = String(value)
      return /[",\n]/.test(stringValue) ? `"${stringValue.replace(/"/g, '""')}"` : stringValue
    }
    const lines = [
      headers.join(","),
      ...rows.map(row =>
        [
          row.accountName,
          row.paymentDate,
          row.lineItem,
          row.productName,
          row.usage,
          row.commission,
          row.commissionRate,
          row.accountId,
          row.status
        ].map(escapeCsv).join(",")
      )
    ]
    const blob = new Blob([lines.join("\r\n")], { type: "text/csv;charset=utf-8;" })
    const url = window.URL.createObjectURL(blob)
    const link = document.createElement("a")
    const timestamp = new Date().toISOString().replace(/[:T]/g, "-").split(".")[0]
    link.href = url
    link.download = `deposit-line-items-${timestamp}.csv`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    window.URL.revokeObjectURL(url)
    showSuccess(
      `Exported ${rows.length} line item${rows.length === 1 ? "" : "s"}`,
      "Check your downloads for the CSV file."
    )
  }, [lineItemRows, selectedLineItems, showError, showSuccess])

  const handleBulkScheduleLink = useCallback(() => {
    if (selectedSchedules.length === 0) {
      showError("No schedules selected", "Select at least one schedule to link.")
      return
    }
    showSuccess(
      `${selectedSchedules.length} schedule${selectedSchedules.length === 1 ? "" : "s"} linked`,
      "The selected schedules have been linked to the deposit."
    )
  }, [selectedSchedules.length, showError, showSuccess])

  const handleBulkScheduleReconcile = useCallback(() => {
    if (selectedSchedules.length === 0) {
      showError("No schedules selected", "Select at least one schedule to update.")
      return
    }
    setScheduleRows(previous =>
      previous.map(row =>
        selectedSchedules.includes(row.id) ? { ...row, status: "Reconciled" } : row
      )
    )
    setSelectedSchedules([])
    showSuccess(
      `${selectedSchedules.length} schedule${selectedSchedules.length === 1 ? "" : "s"} updated`,
      "Marked the selected schedules as Reconciled."
    )
  }, [selectedSchedules, showError, showSuccess])

  const handleBulkScheduleExport = useCallback(() => {
    if (selectedSchedules.length === 0) {
      showError("No schedules selected", "Select at least one schedule to export.")
      return
    }
    const rows = scheduleRows.filter(row => selectedSchedules.includes(row.id))
    if (rows.length === 0) {
      showError("Schedules unavailable", "Unable to locate the selected schedules.")
      return
    }
    const headers = [
      "Name",
      "Number",
      "Date",
      "Account Legal Name",
      "Product",
      "Vendor Name",
      "Quantity",
      "Price Each",
      "Expected Usage Gross",
      "Expected Usage Adjustment",
      "Status"
    ]
    const escapeCsv = (value: unknown) => {
      if (value === null || value === undefined) return ""
      const stringValue = String(value)
      return /[",\n]/.test(stringValue) ? `"${stringValue.replace(/"/g, '""')}"` : stringValue
    }
    const lines = [
      headers.join(","),
      ...rows.map(row =>
        [
          row.name,
          row.number,
          row.date,
          row.accountLegalName,
          row.product,
          row.vendorName,
          row.quantity,
          row.priceEach,
          row.expectedUsageGross,
          row.expectedUsageAdjust,
          row.status
        ].map(escapeCsv).join(",")
      )
    ]
    const blob = new Blob([lines.join("\r\n")], { type: "text/csv;charset=utf-8;" })
    const url = window.URL.createObjectURL(blob)
    const link = document.createElement("a")
    const timestamp = new Date().toISOString().replace(/[:T]/g, "-").split(".")[0]
    link.href = url
    link.download = `revenue-schedules-${timestamp}.csv`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    window.URL.revokeObjectURL(url)
    showSuccess(
      `Exported ${rows.length} schedule${rows.length === 1 ? "" : "s"}`,
      "Check your downloads for the CSV file."
    )
  }, [scheduleRows, selectedSchedules, showError, showSuccess])

  const lineBulkActions = useMemo<BulkActionsGridProps>(
    () => ({
      selectedCount: selectedLineItems.length,
      entityName: "line items",
      actions: [
        {
          key: "match",
          label: "Match",
          icon: ClipboardCheck,
          tone: "primary",
          onClick: handleBulkLineMatch
        },
        {
          key: "unmatch",
          label: "Mark Unmatched",
          icon: Trash2,
          tone: "danger",
          onClick: handleBulkLineUnmatch
        },
        {
          key: "export",
          label: "Export CSV",
          icon: FileDown,
          tone: "info",
          onClick: handleBulkLineExport
        }
      ]
    }),
    [handleBulkLineExport, handleBulkLineMatch, handleBulkLineUnmatch, selectedLineItems.length]
  )

  const scheduleBulkActions = useMemo<BulkActionsGridProps>(
    () => ({
      selectedCount: selectedSchedules.length,
      entityName: "schedules",
      actions: [
        {
          key: "link",
          label: "Link",
          icon: Link2,
          tone: "primary",
          onClick: handleBulkScheduleLink
        },
        {
          key: "reconcile",
          label: "Mark Reconciled",
          icon: ClipboardCheck,
          tone: "neutral",
          onClick: handleBulkScheduleReconcile
        },
        {
          key: "export",
          label: "Export CSV",
          icon: FileDown,
          tone: "info",
          onClick: handleBulkScheduleExport
        }
      ]
    }),
    [
      handleBulkScheduleExport,
      handleBulkScheduleLink,
      handleBulkScheduleReconcile,
      selectedSchedules.length
    ]
  )

  const formattedDate = useMemo(() => {
    const parsed = new Date(metadata.depositDate)
    return Number.isNaN(parsed.getTime()) ? metadata.depositDate : dateFormatter.format(parsed)
  }, [metadata.depositDate, dateFormatter])

  return (
    <div className="flex min-h-[calc(100vh-110px)] flex-col gap-3 px-4 pb-4 pt-3 sm:px-6">
      <div className="flex-shrink-0 space-y-1.5">
        <p className="text-[11px] font-semibold uppercase tracking-wide text-primary-600">Deposit Reconciliation</p>
        <div className="grid grid-cols-8 gap-4 text-sm font-medium text-slate-700">
          <div className="col-span-2 min-w-0">
            <MetaStat label="Deposit Name" value={metadata.depositName} emphasis wrapValue />
          </div>
          <MetaStat label="Date" value={formattedDate} />
          <MetaStat label="Created By" value={metadata.createdBy} />
          <MetaStat label="Payment Type" value={metadata.paymentType} />
          <MetaStat label="Usage Total" value={currencyFormatter.format(metadata.usageTotal)} emphasis />
          <MetaStat label="Unallocated" value={currencyFormatter.format(metadata.unallocated)} emphasis />
          <MetaStat label="Allocated" value={currencyFormatter.format(metadata.allocated)} emphasis />
        </div>
      </div>

      <section className="flex min-h-0 flex-1 flex-col rounded-2xl border border-slate-100 bg-white px-5 py-4 shadow-sm">
        <div className="-mx-5 -mt-4 border-b border-slate-100 px-5 pt-4">
          <ListHeader
            pageTitle="DEPOSIT LINE ITEMS"
            searchPlaceholder="Search deposit line items"
            onSearch={setLineSearch}
            showStatusFilter={false}
            showCreateButton={false}
            showColumnFilters={false}
            compact
            inTab
            bulkActions={lineBulkActions}
            leftAccessory={
              <div className="ml-auto flex items-center gap-2">
                <DepositLineStatusFilterDropdown value={lineTab} onChange={setLineTab} />
              </div>
            }
          />
        </div>
        <div className="flex min-h-0 flex-1 pt-4">
          <DynamicTable
            columns={lineColumns}
            data={filteredLineItems}
            loading={loading}
            emptyMessage="No deposit line items found"
            fillContainerWidth
            selectedItems={selectedLineItems}
            onItemSelect={(itemId, selected) => handleLineItemSelect(String(itemId), selected)}
            onSelectAll={handleLineItemSelectAll}
            selectHeaderLabel="Select"
            className="flex-1"
          />
        </div>
      </section>

      <section className="flex min-h-0 flex-1 flex-col rounded-2xl border border-slate-100 bg-white px-5 py-4 shadow-sm">
        <div className="-mx-5 -mt-4 border-b border-slate-100 px-5 pt-4">
          <ListHeader
            pageTitle="SUGGESTED MATCHES - REVENUE SCHEDULES"
            searchPlaceholder="Search revenue schedules"
            onSearch={setScheduleSearch}
            showStatusFilter={false}
            showCreateButton={false}
            showColumnFilters={false}
            compact
            inTab
            bulkActions={scheduleBulkActions}
            leftAccessory={
              <div className="ml-auto flex items-center gap-2">
                <ReconciliationScheduleStatusFilterDropdown
                  value={scheduleTab}
                  onChange={setScheduleTab}
                />
              </div>
            }
          />
        </div>
        <div className="flex min-h-0 flex-1 pt-4">
          <DynamicTable
            columns={scheduleColumns}
            data={filteredSchedules}
            loading={loading}
            emptyMessage="No suggested schedules found"
            fillContainerWidth
            selectedItems={selectedSchedules}
            onItemSelect={(itemId, selected) => handleScheduleSelect(String(itemId), selected)}
            onSelectAll={handleScheduleSelectAll}
            selectHeaderLabel="Select"
            className="flex-1"
          />
        </div>
      </section>
      <ToastContainer />
    </div>
  )
}
